package table

import (
	"github.com/mattn/go-runewidth"
	"github.com/rprtr258/fun"

	"github.com/rprtr258/tea"
	"github.com/rprtr258/tea/components/box"
	"github.com/rprtr258/tea/components/key"
	"github.com/rprtr258/tea/components/viewport"
	"github.com/rprtr258/tea/styles"
)

// Model defines a state for the table widget
type Model struct {
	KeyMap KeyMap

	cols   []Column
	rows   [][]string
	cursor int
	styles Styles

	viewport viewport.Model
}

// Column defines the table structure
type Column struct {
	Title string
	Width int
}

// KeyMap defines keybindings.
// It satisfies to the help.KeyMap interface, which is used to render the menu.
type KeyMap struct {
	LineUp, LineDown         key.Binding
	PageUp, PageDown         key.Binding
	HalfPageUp, HalfPageDown key.Binding
	GotoTop, GotoBottom      key.Binding
}

// DefaultKeyMap returns a default set of keybindings
var DefaultKeyMap = KeyMap{
	LineUp: key.Binding{
		Keys: []string{"up", "k"},
		Help: key.Help{"↑/k", "up"},
	},
	LineDown: key.Binding{
		Keys: []string{"down", "j"},
		Help: key.Help{"↓/j", "down"},
	},
	PageUp: key.Binding{
		Keys: []string{"b", "pgup"},
		Help: key.Help{"b/pgup", "page up"},
	},
	PageDown: key.Binding{
		Keys: []string{"f", "pgdown", " "},
		Help: key.Help{"f/pgdn", "page down"},
	},
	HalfPageUp: key.Binding{
		Keys: []string{"u", "ctrl+u"},
		Help: key.Help{"u", "½ page up"},
	},
	HalfPageDown: key.Binding{
		Keys: []string{"d", "ctrl+d"},
		Help: key.Help{"d", "½ page down"},
	},
	GotoTop: key.Binding{
		Keys: []string{"home", "g"},
		Help: key.Help{"g/home", "go to start"},
	},
	GotoBottom: key.Binding{
		Keys: []string{"end", "G"},
		Help: key.Help{"G/end", "go to end"},
	},
}

// Styles contains style definitions for this list component.
// By default, these values are generated by DefaultStyles.
type Styles struct {
	Header   styles.Style
	Cell     styles.Style
	Selected styles.Style
}

// DefaultStyles returns a set of default style definitions for this table
var DefaultStyles = Styles{
	Selected: styles.Style{}.Bold(true).Foreground(styles.FgColor("212")),
	Header:   styles.Style{}.Bold(true), /*.Padding(0, 1)*/
	Cell:     styles.Style{},            /*.Padding(0, 1)*/
}

// Option is used to set options in New. For example:
//
//	table := New(WithColumns([]Column{{Title: "ID", Width: 10}}))
type Option func(*Model)

// WithColumns sets the table columns (headers)
func WithColumns(cols []Column) Option {
	return func(m *Model) {
		m.cols = cols
	}
}

// WithRows sets the table rows (data)
func WithRows(rows ...[]string) Option {
	return func(m *Model) {
		m.rows = rows
	}
}

// WithHeight sets the height of the table
func WithHeight(h int) Option {
	return func(m *Model) {
		m.viewport.Height = h
	}
}

// WithWidth sets the width of the table
func WithWidth(w int) Option {
	return func(m *Model) {
		m.viewport.Width = w
	}
}

// WithStyles sets the table styles
func WithStyles(s Styles) Option {
	return func(m *Model) {
		m.styles = s
	}
}

// WithKeyMap sets the key map
func WithKeyMap(km KeyMap) Option {
	return func(m *Model) {
		m.KeyMap = km
	}
}

// New creates a new model for the table widget
func New(opts ...Option) Model {
	m := Model{
		cursor:   0,
		viewport: viewport.New(0, 20),

		KeyMap: DefaultKeyMap,
		styles: DefaultStyles,
	}
	for _, opt := range opts {
		opt(&m)
	}
	return m
}

// SetStyles sets the table styles
func (m *Model) SetStyles(s Styles) {
	m.styles = s
}

// Update is the Tea update loop
func (m *Model) Update(msg tea.Msg) {
	if msg, ok := msg.(tea.MsgKey); ok {
		switch {
		case key.Matches(msg, m.KeyMap.LineUp):
			m.MoveUp(1)
		case key.Matches(msg, m.KeyMap.LineDown):
			m.MoveDown(1)
		case key.Matches(msg, m.KeyMap.PageUp):
			m.MoveUp(m.viewport.Height)
		case key.Matches(msg, m.KeyMap.PageDown):
			m.MoveDown(m.viewport.Height)
		case key.Matches(msg, m.KeyMap.HalfPageUp):
			m.MoveUp(m.viewport.Height / 2)
		case key.Matches(msg, m.KeyMap.HalfPageDown):
			m.MoveDown(m.viewport.Height / 2)
		case key.Matches(msg, m.KeyMap.GotoTop):
			m.GotoTop()
		case key.Matches(msg, m.KeyMap.GotoBottom):
			m.GotoBottom()
		}
	}
}

// SelectedRow returns the selected row.
// You can cast it to your own implementation.
func (m *Model) SelectedRow() []string {
	if m.cursor < 0 || m.cursor >= len(m.rows) {
		return nil
	}

	return m.rows[m.cursor]
}

// Rows returns the current rows
func (m *Model) Rows() [][]string {
	return m.rows
}

// SetRows sets a new rows state
func (m *Model) SetRows(r ...[]string) {
	m.rows = r
}

// SetColumns sets a new columns state
func (m *Model) SetColumns(c []Column) {
	m.cols = c
}

// SetWidth sets the width of the viewport of the table
func (m *Model) SetWidth(w int) {
	m.viewport.Width = w
}

// SetHeight sets the height of the viewport of the table
func (m *Model) SetHeight(h int) {
	m.viewport.Height = h
}

// Height returns the viewport height of the table
func (m *Model) Height() int {
	return m.viewport.Height
}

// Width returns the viewport width of the table
func (m *Model) Width() int {
	return m.viewport.Width
}

// Cursor returns the index of the selected row
func (m *Model) Cursor() int {
	return m.cursor
}

// SetCursor sets the cursor position in the table
func (m *Model) SetCursor(n int) {
	m.cursor = fun.Clamp(n, 0, len(m.rows)-1)
}

// MoveUp moves the selection up by any number of rows.
// It can not go above the first row.
func (m *Model) MoveUp(n int) {
	newCursor := max(m.cursor-n, 0)
	if newCursor < m.viewport.YOffset || m.cursor-newCursor >= m.viewport.Height {
		m.viewport.SetYOffset(newCursor)
	}
	m.cursor = newCursor
}

// MoveDown moves the selection down by any number of rows.
// It can not go below the last row.
func (m *Model) MoveDown(n int) {
	newCursor := min(m.cursor+n, len(m.rows)-1)
	if newCursor-m.viewport.Height >= m.viewport.YOffset || newCursor-m.cursor >= m.viewport.Height {
		m.viewport.SetYOffset(newCursor - m.viewport.Height + 1)
	}
	m.cursor = newCursor
}

// GotoTop moves the selection to the first row
func (m *Model) GotoTop() {
	m.MoveUp(m.cursor)
}

// GotoBottom moves the selection to the last row
func (m *Model) GotoBottom() {
	m.MoveDown(len(m.rows))
}

// View renders the component
func (m *Model) View(vb tea.Viewbox) {
	const _gap = 2
	// 2 for borders, 2 for margin
	totalWidth := 2 + 2 + _gap*(len(m.cols)-1)
	for _, col := range m.cols {
		totalWidth += col.Width
	}

	vb = vb.
		MaxWidth(totalWidth).
		// 2 for borders, 1 for header, 1 for split line
		MaxHeight(2 + 2 + m.viewport.Height)
	box.Box(
		vb,
		func(vb tea.Viewbox) {
			// header
			vbh := vb.Styled(m.styles.Header).PaddingLeft(1)
			for _, col := range m.cols {
				vbh.WriteLine(runewidth.Truncate(col.Title, col.Width, "…"))
				vbh = vbh.PaddingLeft(col.Width).PaddingLeft(_gap)
			}

			// split line
			vb.Row(1).Styled(styles.Style{}.Foreground(styles.FgColor("240"))).Fill(box.NormalBorder.Top)

			// rows
			m.viewport.View(vb.PaddingTop(2), func(vbRow tea.Viewbox, i int) {
				if i == m.cursor {
					vbRow = vbRow.Styled(m.styles.Selected)
				}

				vbRow = vbRow.PaddingLeft(1)
				for i, value := range m.rows[i] {
					vbRow.WriteLine(m.styles.Cell.Render(runewidth.Truncate(value, m.cols[i].Width, "…")))
					vbRow = vbRow.PaddingLeft(m.cols[i].Width).PaddingLeft(_gap)
				}
			})
		},
		box.NormalBorder,
		box.BorderMaskAll,
		box.Colors(nil),
		box.Colors(styles.FgColor("240")),
	)
}
