package cursor

import (
	"time"

	"github.com/rprtr258/tea"
	"github.com/rprtr258/tea/lipgloss"
)

const defaultBlinkSpeed = time.Millisecond * 530

// msgInitialBlink initializes cursor blinking.
type msgInitialBlink struct{}

// MsgBlink signals that the cursor should blink. It contains metadata that
// allows us to tell if the blink message is the one we're expecting.
type MsgBlink struct {
	id  int
	tag int
}

// Mode describes the behavior of the cursor.
type Mode int

// Available cursor modes.
const (
	CursorBlink Mode = iota
	CursorStatic
	CursorHide
)

// String returns the cursor mode in a human-readable format. This method is
// provisional and for informational purposes only.
func (c Mode) String() string {
	return [...]string{
		"blink",
		"static",
		"hidden",
	}[c]
}

// Model is the Bubble Tea model for this cursor element.
type Model struct {
	// BlinkSpeed time.Duration
	// Style for styling the cursor block.
	Style lipgloss.Style
	// TextStyle is the style used for the cursor when it is hidden (when blinking).
	// I.e. displaying normal text.
	TextStyle lipgloss.Style

	// char is the character under the cursor
	char string
	// The ID of this Model as it relates to other cursors
	id int
	// focus indicates whether the containing input is focused
	focus bool
	// Cursor Blink state.
	Blink bool
	// Used to manage cursor blink
	blinkCtx *time.Ticker
	// The ID of the blink message we're expecting to receive.
	blinkTag int
	// mode determines the behavior of the cursor
	mode Mode
}

// New creates a new model with default settings.
func New() Model {
	return Model{
		// BlinkSpeed: defaultBlinkSpeed,

		Blink: true,
		mode:  CursorBlink,

		blinkCtx: time.NewTicker(defaultBlinkSpeed),
	}
}

// Update updates the cursor.
func (m *Model) Update(msg tea.Msg) []tea.Cmd {
	switch msg := msg.(type) {
	case msgInitialBlink:
		// We accept all initialBlinkMsgs generated by the Blink command.

		if m.mode != CursorBlink || !m.focus {
			return nil
		}

		return m.CmdBlink()
	case MsgBlink:
		// We're choosy about whether to accept blinkMsgs so that our cursor
		// only exactly when it should.

		// Is this model blink-able?
		if m.mode != CursorBlink || !m.focus {
			return nil
		}

		// Were we expecting this blink message?
		if msg.id != m.id || msg.tag != m.blinkTag {
			return nil
		}

		if m.mode == CursorBlink {
			m.Blink = !m.Blink
			return m.CmdBlink()
		}

		return nil
	}
	return nil
}

// Mode returns the model's cursor mode. For available cursor modes, see
// type Mode.
func (m *Model) Mode() Mode {
	return m.mode
}

// SetMode sets the model's cursor mode. This method returns a command.
//
// For available cursor modes, see type CursorMode.
func (m *Model) SetMode(mode Mode) []tea.Cmd {
	m.mode = mode
	m.Blink = m.mode == CursorHide || !m.focus
	if mode == CursorBlink {
		return []tea.Cmd{CmdBlink}
	}
	return nil
}

// BlinkCmd is a command used to manage cursor blinking.
func (m *Model) CmdBlink() []tea.Cmd {
	if m.mode != CursorBlink {
		return nil
	}

	m.blinkCtx.Reset(defaultBlinkSpeed)

	m.blinkTag++

	return []tea.Cmd{func() tea.Msg {
		<-m.blinkCtx.C
		return MsgBlink{id: m.id, tag: m.blinkTag}
	}}
}

// CmdBlink is a command used to initialize cursor blinking.
func CmdBlink() tea.Msg {
	return msgInitialBlink{}
}

// Focus focuses the cursor to allow it to blink if desired.
func (m *Model) Focus() []tea.Cmd {
	m.focus = true
	m.Blink = m.mode == CursorHide // show the cursor unless we've explicitly hidden it

	if m.mode == CursorBlink && m.focus {
		return m.CmdBlink()
	}
	return nil
}

// Blur blurs the cursor.
func (m *Model) Blur() {
	m.focus = false
	m.Blink = true
}

// SetChar sets the character under the cursor.
func (m *Model) SetChar(char string) {
	m.char = char
}

// View displays the cursor.
func (m *Model) View() string {
	if m.Blink {
		return m.TextStyle.Inline(true).Render(m.char)
	}
	return m.Style.Inline(true).Reverse(true).Render(m.char)
}
